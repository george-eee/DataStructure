// 前言：本项目用于介绍常见的数据结构和算法知识 主要侧重于C++代码实现
// 本项目中的知识体系和代码参考于 <<hello-algo>> 和 <<Big talk data structure>> 这两本书
// 本项目采用 single source file-single chapter 设计理念 在运行本项目中的代码时推荐只编译单个源文件

// 何为算法(algorithm)？
// 定义；算法是在‘有限时间内’解决‘特定 ’问题的一组指令或操作步骤 它具有以下特点：
// 1.问题是明确的
// 2.具有可行性
// 3.各步骤都有确定的含义

// 何为数据结构(datastructure)？
// 定义：数据结构是计算机组织和存储数据的方式 它具有以下设计追求：
// 1.尽可能节省内存
// 2.数据操作尽可能节省时间(常见的数据操作：增删改查)
// 3.提供简洁的数据表示和逻辑信息
// 数据结构的设计是一个充满权衡的过程 时间效率和空间效率之间彼此是平衡的 我们常说的“以时间换空间”或“以空间换时间”也正是因为如此
// 数据结构和算法的关系？
// 数据结构是算法的基石 算法是数据结构发挥作用的舞台

// 算法的复杂度分析
// 为何要进行复杂度分析？
// 因为我们往往想要追求时间和空间效率上的最优解 而评价一个算法是否足够优异就需要依赖于对其进行分析处理
// 常用的分析方式有两种 一种是通过代入完整数据进行测试 得到实际分析结果 另一种通过渐进复杂度分析(简称为复杂度分析)得到估算结果
// 前者相较于后者具有受硬件配置影响和耗时耗力的缺点 所以我们一般选择进行复杂度分析
// 定义：通过描述算法随着数据体量增大时所需时间和空间的增长趋势 我们就得到了算法的时间和空间复杂度

// 时间复杂度：假定算法每进行一次操作耗时t n次操作总耗时T(n) 则时间复杂度就取决于T(n)中最高阶的项(常数项和所有系数都可以忽略) 我们规定采用“大O阶”表示法来表示时间复杂度
// 常见的时间复杂度：O(1)	<	O(logn)	<	O(n)	<	O(nlogn)	<	O(n^2)	<	O(2^n)	<	O(n!)
// 上述复杂度对应着：常数阶		对数阶		线性阶		线性对数阶		平方阶		指数阶		阶乘阶
// 常数阶：操作时间与数据体量无关
// 对数阶：操作时间与数据体量呈对数关系 对数阶的程序每轮循环都会缩减1/m的数据体量 而O(logn)的底数正是m 只不过由于对数换底公式和系数省略 m与复杂度无关 故而省略 对数阶常出现在分治策略相关的算法中
// 线性阶：操作时间与数据体量呈线性关系 常出现在单重循环中
// 线性对数阶：操作时间与数据体量呈线性对数关系 常出现在嵌套循环中 并且一重循环为O(logn) 另一重为O(n) 主流排序算法时间复杂度通常都为O(nlogn) 如快排 归并排 堆排等
// 平方阶：操作时间与数据体量呈平方关系 常出现在嵌套循环中 并且两重循环都是O(n) 冒泡排序就是O(n^2)
// 指数阶：操作时间与数据体量呈指数关系 常出现于递归函数中 算法中不少穷举算法(bfs dfs 回溯等)都是O(2^n) 但当数据体量较大时 指数阶是不可接受的 通常要使用动态规划或贪心来解决
// 阶乘阶：操作时间与数据体量呈阶乘关系 也是经常出现于递归中 它对应于数学中的全排列问题 同样的 数据体量大时阶乘阶也是不可接受的
// 时间复杂度其实可以分为最佳 最差 平均 时间复杂度 之所以有此区分是因为数据的分布是随机的(有好有坏的)
// 例如排序算法 如果数据一开始就接近排序完全了 那么时间复杂度就很低 反之数据几乎完全逆序 那么时间复杂度就很高 而平均时间复杂度就像是时间复杂度的数学期望 实际问题中很难轻易得出
// 所以我们一般说的时间复杂度都是指的-->最差时间复杂度 它给出了一个效率安全的底线值 让我们可以更安全地使用算法

// 空间复杂度：类比于时间复杂度 将运行时间替换为占用空间即可
// 算法使用的空间可以分为三种：
// 1.输入空间：存储算法的输入数据
// 2.暂存空间：又分为暂存数据 栈帧空间 指令空间
// 暂存数据：算法运行期间的各种常量 变量 对象等
// 栈帧空间：保存调用函数的上下文数据 系统每次调用函数都会在栈顶创建一个栈帧(占用一部分栈空间) 函数执行结束后 栈帧会被弹出 释放栈空间
// 指令空间：保存编译后的程序指令 实际统计中忽略不计
// 3.输出空间：存储算法的输出数据
// 而实际上我们在进行空间复杂度分析时 通常只统计暂存数据 栈帧空间 输出空间三部分
// 值得注意的是 我们在讨论空间复杂度时都只说最差空间复杂度 因为内存空间是一项硬性要求 我们必须要为任何数据下的程序都预留出足够的内存空间
// 而“最差”指的是当数据输入后 算法运行时占用的空间达到了峰值 此时得到的空间复杂度就成为最差空间复杂度
// 常见的空间复杂度：O(1)	<	O(logn)	<	O(n)	<	O(n^2)	<	O(2^n)
// 分别对应着：		常数阶		对数阶		线性阶		平方阶		指数阶
// 常数阶：常见于占用空间与输入数据大小无关的常量 变量 对象 注意！循环中定义变量或调用函数而占用的空间是不计入统计的 因为它们在进入下一循环时就会被释放 不会累计 所以仍然是常数阶
// 对数阶：常见于分治算法 例如归并排序
// 线性阶：常见于元素数量和n成正比的数组 链表 栈 队列等 此外递归往往也是线性阶 当递归深度为n时 空间复杂度:O(n)
// 平方阶：常见于矩阵和图 元素数量和n成平方关系 递归也可能是平方阶 当递归中定义了数组/链表...时 空间复杂度:O(n^2)
// 指数阶：常见于二叉树(如 满二叉)

// 数据结构的划分：从物理上和逻辑上
// 从物理上 所有数据结构都是基于数组 链表或者二者的组合实现的 因为数组在内存中是连续空间存储的 而链表则是离散空间存储 它们各自代表了一种物理存储方式
// 也就是说 数据结构的物理存储方式就三种：1.连续空间存储(称为静态数据结构) 2.离散空间存储(称为动态数据结构) 3.既有连续空间又有离散空间存储(一般称动态数据结构)
// 而大部分数据结构其实既能基于数组实现 又能基于链表实现 所以这里不进行单独罗列了 但是基于二者组合实现的我们一般只考虑哈希表
// 从逻辑上 数据结构可分为线性和非线性两种
// 线性(一对一)：数组 链表 栈 队列 哈希表
// 非线性数据结构又可分为树形结构和网状结构
// 树形结构(一对多)：树 堆 哈希
// 网状结构(多对多)：图
// 注意：哈希表既是线性结构 又是非线性结构

// 文件的字符编码：
// 为了在计算机中表示字符 我们需要将二进制数据转换为相应字符 而转换的方式就是字符集 又称字符编码
// 最早的字符编码是ASCII字符集 使用7bits来表示一个字符(占1Byte) 但是它只能表示英文
// 后来出现了本土化的ANSI(GB2312 GBK等)字符集 使用1Byte来表示英文 使用2Byte来表示汉字 但它无法表示罕见汉字 更无法表示其他更多的文字系统 不过它仍然是极为常用的
// 再后来出现了Unicode字符集 它的设计目的是不断扩容自身以涵盖所有的文字系统 它使用2Bytes来表示英文和常见其他字符 较生僻的字符可能会用3个/4个Bytes来表示
// 但是Unicode字符集并不是完善的解决方式 比如英文原本就只用1Byte即可 于是后来Unicode又衍生出了UTF-8 UTF-16 UTF-32等编码方式
// UTF-8：一种可变长度的编码方式 也是目前通用性最高的编码方式 它用1Byte存储英文 2Bytes存储拉丁和希腊字母 3Bytes存储中文字符 4Bytes存储其他的一些生僻字符
// UTF-16：英文字符和常用的非英文字符(包括中文)用2Bytes存储 少数字符用4Bytes存储
// UTF-32：所有字符都使用4Bytes存储
// 注：使用VS保存源文件时可以通过 文件-高级保存选项 更改文件的字符编码方式 推荐使用UTF-8以提高兼容性和可移植性

// 编程语言的字符编码：
// Java Js C#都采用UTF-16或UTF-32编码 因为字符大小一般相等 这样的字符串就可以当作数组来处理 进行随机存取和计数时间复杂度都只有O(1) 其实选用UTF-16不仅是因为它的优点 更多是因为一些时代因素
// GO Rust使用UTF-8编码 相比之下UTF-8因为是变长编码 所以对字符串的访问等操作往往需要整体遍历 时间复杂度为O(n)
// Python使用Unicode编码 只不过它使用的是一种灵活的Unicode编码方式-->字符串长度取决于字符串中单个字符最大能占多少Byte 全英文则每个都占1Byte 有中文或其他基本语种字符则每个都占2Bytes 有更生僻的字符则每个都占4Bytes
// C C++默认使用ASCII编码 但是在处理ASCII规定以外的字符时则会使用ANSI或者Unicode编码 具体使用哪个取决于编译环境选项等因素
// 例如在VS中 项目-属性-高级 中可以更改C C++使用的字符集：多字节字符集相当于是使用ANSI Unicode字符集则是使用UTF-16 事实上在处理绝大部分ASCII规定以外的字符时两者都看不出什么区别

// 注意：文件的字符编码和编程语言的字符编码是两个完全不同的概念
// 文件的字符编码指的是文件在磁盘上进行写入时将字符转换为二进制的方式 这取决于操作系统和软件对文件的处理方式
// 而编程语言的字符编码指的是程序运行时字符在内存中存储和表现的方式 这只取决于编程语言本身

// DataStructure的引入就到这里了 之后就要开启正式的学习篇章了 加油！